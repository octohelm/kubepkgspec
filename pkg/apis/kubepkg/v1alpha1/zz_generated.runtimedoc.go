/*
Package v1alpha1 GENERATED BY gengo:runtimedoc
DON'T EDIT THIS FILE
*/
package v1alpha1

func (v *ConfigMapSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Data":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *Container) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Image":
			return []string{
				"镜像",
			}, true
		case "WorkingDir":
			return []string{
				"运行目录",
			}, true
		case "Command":
			return []string{
				"命令",
			}, true
		case "Args":
			return []string{
				"参数",
			}, true
		case "Env":
			return []string{
				"环境变量",
			}, true
		case "Ports":
			return []string{
				"暴露端口",
			}, true
		case "Stdin":
			return []string{}, true
		case "StdinOnce":
			return []string{}, true
		case "TTY":
			return []string{}, true
		case "Resources":
			return []string{}, true
		case "LivenessProbe":
			return []string{}, true
		case "ReadinessProbe":
			return []string{}, true
		case "StartupProbe":
			return []string{}, true
		case "Lifecycle":
			return []string{}, true
		case "SecurityContext":
			return []string{}, true
		case "TerminationMessagePath":
			return []string{}, true
		case "TerminationMessagePolicy":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *CronJobSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Schedule":
			return []string{
				"The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.",
			}, true
		case "TimeZone":
			return []string{
				"The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.",
				"If not specified, this will default to the time zone of the kube-controller-manager process.",
				"The set of valid time zone names and the time zone offset is loaded from the system-wide time zone",
				"database by the API server during CronJob validation and the controller manager during execution.",
				"If no system-wide time zone database can be found a bundled version of the database is used instead.",
				"If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host",
				"configuration, the controller will stop creating new new Jobs and will create a system event with the",
				"reason UnknownTimeZone.",
				"More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones",
			}, true
		case "StartingDeadlineSeconds":
			return []string{
				"Optional deadline in seconds for starting the job if it misses scheduled",
				"time for any reason.  Missed jobs executions will be counted as failed ones.",
			}, true
		case "ConcurrencyPolicy":
			return []string{
				"Specifies how to treat concurrent executions of a Job.",
				"Valid values are:",
				"",
				"- \"Allow\" (default): allows CronJobs to run concurrently;",
				"- \"Forbid\": forbids concurrent runs, skipping next run if previous run hasn't finished yet;",
				"- \"Replace\": cancels currently running job and replaces it with a new one",
			}, true
		case "Suspend":
			return []string{
				"This flag tells the controller to suspend subsequent executions, it does",
				"not apply to already started executions.  Defaults to false.",
			}, true
		case "JobTemplate":
			return []string{
				"Specifies the job that will be created when executing a CronJob.",
			}, true
		case "SuccessfulJobsHistoryLimit":
			return []string{
				"The number of successful finished jobs to retain. Value must be non-negative integer.",
				"Defaults to 3.",
			}, true
		case "FailedJobsHistoryLimit":
			return []string{
				"The number of failed finished jobs to retain. Value must be non-negative integer.",
				"Defaults to 1.",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *DaemonSetSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Template":
			return []string{
				"An object that describes the pod that will be created.",
				"The DaemonSet will create exactly one copy of this pod on every node",
				"that matches the template's node selector (or on every node if no node",
				"selector is specified).",
				"The only allowed template.spec.restartPolicy value is \"Always\".",
				"More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template",
			}, true
		case "UpdateStrategy":
			return []string{
				"An update strategy to replace existing DaemonSet pods with new pods.",
			}, true
		case "MinReadySeconds":
			return []string{
				"The minimum number of seconds for which a newly created DaemonSet pod should",
				"be ready without any of its container crashing, for it to be considered",
				"available. Defaults to 0 (pod will be considered available as soon as it",
				"is ready).",
			}, true
		case "RevisionHistoryLimit":
			return []string{
				"The number of old history to retain to allow rollback.",
				"This is a pointer to distinguish between explicit zero and not specified.",
				"Defaults to 10.",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Deploy) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Underlying":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployConfigMap) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployCronJob) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployDaemonSet) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployDeployment) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployEndpoints) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Ports":
			return []string{}, true
		case "Addresses":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployInfrastructure) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Labels":
			return []string{}, true
		case "Annotations":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployJob) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeploySecret) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeployStatefulSet) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Kind":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.DeployInfrastructure, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *DeploymentSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Replicas":
			return []string{
				"Number of desired pods. This is a pointer to distinguish between explicit",
				"zero and not specified. Defaults to 1.",
			}, true
		case "Template":
			return []string{
				"describes the pods that will be created.",
				"The only allowed template.spec.restartPolicy value is \"Always\".",
			}, true
		case "Strategy":
			return []string{
				"The deployment strategy to use to replace existing pods with new ones.",
			}, true
		case "MinReadySeconds":
			return []string{
				"Minimum number of seconds for which a newly created pod should be ready",
				"without any of its container crashing, for it to be considered available.",
				"Defaults to 0 (pod will be considered available as soon as it is ready)",
			}, true
		case "RevisionHistoryLimit":
			return []string{
				"The number of old ReplicaSets to retain to allow rollback.",
				"This is a pointer to distinguish between explicit zero and not specified.",
				"Defaults to 10.",
			}, true
		case "Paused":
			return []string{
				"Indicates that the deployment is paused.",
			}, true
		case "ProgressDeadlineSeconds":
			return []string{
				"The maximum time in seconds for a deployment to make progress before it",
				"is considered to be failed. The deployment controller will continue to",
				"process failed deployments and a condition with a ProgressDeadlineExceeded",
				"reason will be surfaced in the deployment status. Note that progress will",
				"not be estimated during the time a deployment is paused. Defaults to 600s.",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *DigestMeta) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Digest":
			return []string{}, true
		case "Name":
			return []string{}, true
		case "Size":
			return []string{}, true
		case "Tag":
			return []string{}, true
		case "Platform":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (*DigestMetaType) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}

func (v *EnvVarValueOrFrom) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Value":
			return []string{}, true
		case "ValueFrom":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Expose) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Underlying":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *ExposeIngress) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Gateway":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *ExposeNodePort) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (*FileSize) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}

func (v *Image) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Name":
			return []string{
				"镜像名",
			}, true
		case "Tag":
			return []string{
				"镜像标签",
			}, true
		case "Digest":
			return []string{
				"镜像摘要",
			}, true
		case "Platforms":
			return []string{
				"镜像支持的平台",
			}, true
		case "PullPolicy":
			return []string{
				"镜像拉取策略",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *JobSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Parallelism":
			return []string{
				"Specifies the maximum desired number of pods the job should",
				"run at any given time. The actual number of pods running in steady state will",
				"be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism),",
				"i.e. when the work left to do is less than max parallelism.",
				"More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
			}, true
		case "Completions":
			return []string{
				"Specifies the desired number of successfully finished pods the",
				"job should be run with.  Setting to null means that the success of any",
				"pod signals the success of all pods, and allows parallelism to have any positive",
				"value.  Setting to 1 means that parallelism is limited to 1 and the success of that",
				"pod signals the success of the job.",
				"More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
			}, true
		case "ActiveDeadlineSeconds":
			return []string{
				"Specifies the duration in seconds relative to the startTime that the job",
				"may be continuously active before the system tries to terminate it; value",
				"must be positive integer. If a Job is suspended (at creation or through an",
				"update), this timer will effectively be stopped and reset when the Job is",
				"resumed again.",
			}, true
		case "PodFailurePolicy":
			return []string{
				"Specifies the policy of handling failed pods. In particular, it allows to",
				"specify the set of actions and conditions which need to be",
				"satisfied to take the associated action.",
				"If empty, the default behaviour applies - the counter of failed pods,",
				"represented by the jobs's .status.failed field, is incremented and it is",
				"checked against the backoffLimit. This field cannot be used in combination",
				"with restartPolicy=OnFailure.",
			}, true
		case "SuccessPolicy":
			return []string{
				"successPolicy specifies the policy when the Job can be declared as succeeded.",
				"If empty, the default behavior applies - the Job is declared as succeeded",
				"only when the number of succeeded pods equals to the completions.",
				"When the field is specified, it must be immutable and works only for the Indexed Jobs.",
				"Once the Job meets the SuccessPolicy, the lingering pods are terminated.",
				"",
				"This field is beta-level. To use this field, you must enable the",
				"`JobSuccessPolicy` feature gate (enabled by default).",
			}, true
		case "BackoffLimit":
			return []string{
				"Specifies the number of retries before marking this job failed.",
				"Defaults to 6",
			}, true
		case "BackoffLimitPerIndex":
			return []string{
				"Specifies the limit for the number of retries within an",
				"index before marking this index as failed. When enabled the number of",
				"failures per index is kept in the pod's",
				"batch.kubernetes.io/job-index-failure-count annotation. It can only",
				"be set when Job's completionMode=Indexed, and the Pod's restart",
				"policy is Never. The field is immutable.",
				"This field is beta-level. It can be used when the `JobBackoffLimitPerIndex`",
				"feature gate is enabled (enabled by default).",
			}, true
		case "MaxFailedIndexes":
			return []string{
				"Specifies the maximal number of failed indexes before marking the Job as",
				"failed, when backoffLimitPerIndex is set. Once the number of failed",
				"indexes exceeds this number the entire Job is marked as Failed and its",
				"execution is terminated. When left as null the job continues execution of",
				"all of its indexes and is marked with the `Complete` Job condition.",
				"It can only be specified when backoffLimitPerIndex is set.",
				"It can be null or up to completions. It is required and must be",
				"less than or equal to 10^4 when is completions greater than 10^5.",
				"This field is beta-level. It can be used when the `JobBackoffLimitPerIndex`",
				"feature gate is enabled (enabled by default).",
			}, true
		case "ManualSelector":
			return []string{
				"manualSelector controls generation of pod labels and pod selectors.",
				"Leave `manualSelector` unset unless you are certain what you are doing.",
				"When false or unset, the system pick labels unique to this job",
				"and appends those labels to the pod template.  When true,",
				"the user is responsible for picking unique labels and specifying",
				"the selector.  Failure to pick a unique label may cause this",
				"and other jobs to not function correctly.  However, You may see",
				"`manualSelector=true` in jobs that were created with the old `extensions/v1beta1`",
				"API.",
				"More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector",
			}, true
		case "Template":
			return []string{
				"Describes the pod that will be created when executing a job.",
				"The only allowed template.spec.restartPolicy values are \"Never\" or \"OnFailure\".",
				"More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/",
			}, true
		case "TTLSecondsAfterFinished":
			return []string{
				"ttlSecondsAfterFinished limits the lifetime of a Job that has finished",
				"execution (either Complete or Failed). If this field is set,",
				"ttlSecondsAfterFinished after the Job finishes, it is eligible to be",
				"automatically deleted. When the Job is being deleted, its lifecycle",
				"guarantees (e.g. finalizers) will be honored. If this field is unset,",
				"the Job won't be automatically deleted. If this field is set to zero,",
				"the Job becomes eligible to be deleted immediately after it finishes.",
			}, true
		case "CompletionMode":
			return []string{
				"completionMode specifies how Pod completions are tracked. It can be",
				"`NonIndexed` (default) or `Indexed`.",
				"",
				"`NonIndexed` means that the Job is considered complete when there have",
				"been .spec.completions successfully completed Pods. Each Pod completion is",
				"homologous to each other.",
				"",
				"`Indexed` means that the Pods of a",
				"Job get an associated completion index from 0 to (.spec.completions - 1),",
				"available in the annotation batch.kubernetes.io/job-completion-index.",
				"The Job is considered complete when there is one successfully completed Pod",
				"for each index.",
				"When value is `Indexed`, .spec.completions must be specified and",
				"`.spec.parallelism` must be less than or equal to 10^5.",
				"In addition, The Pod name takes the form",
				"`$(job-name)-$(index)-$(random-string)`,",
				"the Pod hostname takes the form `$(job-name)-$(index)`.",
				"",
				"More completion modes can be added in the future.",
				"If the Job controller observes a mode that it doesn't recognize, which",
				"is possible during upgrades due to version skew, the controller",
				"skips updates for the Job.",
			}, true
		case "Suspend":
			return []string{
				"suspend specifies whether the Job controller should create Pods or not. If",
				"a Job is created with suspend set to true, no Pods are created by the Job",
				"controller. If a Job is suspended after creation (i.e. the flag goes from",
				"false to true), the Job controller will delete all active Pods associated",
				"with this Job. Users must design their workload to gracefully handle this.",
				"Suspending a Job will reset the StartTime field of the Job, effectively",
				"resetting the ActiveDeadlineSeconds timer too. Defaults to false.",
			}, true
		case "PodReplacementPolicy":
			return []string{
				"podReplacementPolicy specifies when to create replacement Pods.",
				"Possible values are:",
				"- TerminatingOrFailed means that we recreate pods",
				"when they are terminating (has a metadata.deletionTimestamp) or failed.",
				"- Failed means to wait until a previously created Pod is fully terminated (has phase",
				"Failed or Succeeded) before creating a replacement Pod.",
				"",
				"When using podFailurePolicy, Failed is the the only allowed value.",
				"TerminatingOrFailed and Failed are allowed values when podFailurePolicy is not in use.",
				"This is an beta field. To use this, enable the JobPodReplacementPolicy feature toggle.",
				"This is on by default.",
			}, true
		case "ManagedBy":
			return []string{
				"field indicates the controller that manages a Job. The k8s Job",
				"controller reconciles jobs which don't have this field at all or the field",
				"value is the reserved string `kubernetes.io/job-controller`, but skips",
				"reconciling Jobs with a custom value for this field.",
				"The value must be a valid domain-prefixed path (e.g. acme.io/foo) -",
				"all characters before the first \"/\" must be a valid subdomain as defined",
				"by RFC 1123. All characters trailing the first \"/\" must be valid HTTP Path",
				"characters as defined by RFC 3986. The value cannot exceed 63 characters.",
				"This field is immutable.",
				"",
				"This field is beta-level. The job controller accepts setting the field",
				"when the feature gate JobManagedBy is enabled (enabled by default).",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *JobTemplateSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Spec":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *KubePkg) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Spec":
			return []string{}, true
		case "Status":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.TypeMeta, "", names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(&v.ObjectMeta, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *KubePkgList) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Items":
			return []string{}, true
		}
		if doc, ok := runtimeDoc(&v.TypeMeta, "", names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(&v.ListMeta, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *PodPartialSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "RestartPolicy":
			return []string{
				"Restart policy for all containers within the pod.",
				"One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.",
				"Default to Always.",
				"More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
			}, true
		case "TerminationGracePeriodSeconds":
			return []string{
				"Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.",
				"Value must be non-negative integer. The value zero indicates stop immediately via",
				"the kill signal (no opportunity to shut down).",
				"If this value is nil, the default grace period will be used instead.",
				"The grace period is the duration in seconds after the processes running in the pod are sent",
				"a termination signal and the time when the processes are forcibly halted with a kill signal.",
				"Set this value longer than the expected cleanup time for your process.",
				"Defaults to 30 seconds.",
			}, true
		case "ActiveDeadlineSeconds":
			return []string{
				"Optional duration in seconds the pod may be active on the node relative to",
				"StartTime before the system will actively try to mark it failed and kill associated containers.",
				"Value must be a positive integer.",
			}, true
		case "DNSPolicy":
			return []string{
				"Set DNS policy for the pod.",
				"Defaults to \"ClusterFirst\".",
				"Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.",
				"DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.",
				"To have DNS options set along with hostNetwork, you have to specify DNS policy",
				"explicitly to 'ClusterFirstWithHostNet'.",
			}, true
		case "NodeSelector":
			return []string{
				"is a selector which must be true for the pod to fit on a node.",
				"Selector which must match a node's labels for the pod to be scheduled on that node.",
				"More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
			}, true
		case "AutomountServiceAccountToken":
			return []string{
				"indicates whether a service account token should be automatically mounted.",
			}, true
		case "NodeName":
			return []string{
				"indicates in which node this pod is scheduled.",
				"If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.",
				"Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.",
				"This field should not be used to express a desire for the pod to be scheduled on a specific node.",
				"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
			}, true
		case "HostNetwork":
			return []string{
				"Host networking requested for this pod. Use the host's network namespace.",
				"If this option is set, the ports that will be used must be specified.",
				"Default to false.",
			}, true
		case "HostPID":
			return []string{
				"Use the host's pid namespace.",
				"Optional: Default to false.",
			}, true
		case "HostIPC":
			return []string{
				"Use the host's ipc namespace.",
				"Optional: Default to false.",
			}, true
		case "ShareProcessNamespace":
			return []string{
				"Share a single process namespace between all of the containers in a pod.",
				"When this is set containers will be able to view and signal processes from other containers",
				"in the same pod, and the first process in each container will not be assigned PID 1.",
				"HostPID and ShareProcessNamespace cannot both be set.",
				"Optional: Default to false.",
			}, true
		case "SecurityContext":
			return []string{
				"holds pod-level security attributes and common container settings.",
				"Optional: Defaults to empty.  See type description for default values of each field.",
			}, true
		case "ImagePullSecrets":
			return []string{
				"is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.",
				"If specified, these secrets will be passed to individual puller implementations for them to use.",
				"More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
			}, true
		case "Hostname":
			return []string{
				"Specifies the hostname of the Pod",
				"If not specified, the pod's hostname will be set to a system-defined value.",
			}, true
		case "Subdomain":
			return []string{
				"If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\".",
				"If not specified, the pod will not have a domainname at all.",
			}, true
		case "Affinity":
			return []string{
				"If specified, the pod's scheduling constraints",
			}, true
		case "SchedulerName":
			return []string{
				"If specified, the pod will be dispatched by specified scheduler.",
				"If not specified, the pod will be dispatched by default scheduler.",
			}, true
		case "Tolerations":
			return []string{
				"If specified, the pod's tolerations.",
			}, true
		case "HostAliases":
			return []string{
				"is an optional list of hosts and IPs that will be injected into the pod's hosts",
				"file if specified.",
			}, true
		case "PriorityClassName":
			return []string{
				"If specified, indicates the pod's priority. \"system-node-critical\" and",
				"\"system-cluster-critical\" are two special keywords which indicate the",
				"highest priorities with the former being the highest priority. Any other",
				"name must be defined by creating a PriorityClass object with that name.",
				"If not specified, the pod priority will be default or zero if there is no",
				"default.",
			}, true
		case "Priority":
			return []string{
				"The priority value. Various system components use this field to find the",
				"priority of the pod. When Priority Admission Controller is enabled, it",
				"prevents users from setting this field. The admission controller populates",
				"this field from PriorityClassName.",
				"The higher the value, the higher the priority.",
			}, true
		case "DNSConfig":
			return []string{
				"Specifies the DNS parameters of a pod.",
				"Parameters specified here will be merged to the generated DNS",
				"configuration based on DNSPolicy.",
			}, true
		case "ReadinessGates":
			return []string{
				"If specified, all readiness gates will be evaluated for pod readiness.",
				"A pod is ready when all its containers are ready AND",
				"all conditions specified in the readiness gates have status equal to \"True\"",
				"More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
			}, true
		case "RuntimeClassName":
			return []string{
				"refers to a RuntimeClass object in the node.k8s.io group, which should be used",
				"to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.",
				"If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an",
				"empty definition that uses the default runtime handler.",
				"More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
			}, true
		case "EnableServiceLinks":
			return []string{
				"indicates whether information about services should be injected into pod's",
				"environment variables, matching the syntax of Docker links.",
				"Optional: Defaults to true.",
			}, true
		case "PreemptionPolicy":
			return []string{
				"is the Policy for preempting pods with lower priority.",
				"One of Never, PreemptLowerPriority.",
				"Defaults to PreemptLowerPriority if unset.",
			}, true
		case "Overhead":
			return []string{
				"represents the resource overhead associated with running a pod for a given RuntimeClass.",
				"This field will be autopopulated at admission time by the RuntimeClass admission controller. If",
				"the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.",
				"The RuntimeClass admission controller will reject Pod create requests which have the overhead already",
				"set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value",
				"defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.",
				"More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
			}, true
		case "TopologySpreadConstraints":
			return []string{
				"describes how a group of pods ought to spread across topology",
				"domains. Scheduler will schedule pods in a way which abides by the constraints.",
				"All topologySpreadConstraints are ANDed.",
			}, true
		case "SetHostnameAsFQDN":
			return []string{
				"If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).",
				"In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).",
				"In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN.",
				"If a pod does not have FQDN, this has no effect.",
				"Default to false.",
			}, true
		case "OS":
			return []string{
				"Specifies the OS of the containers in the pod.",
				"Some pod and container fields are restricted if this is set.",
				"",
				"If the OS field is set to linux, the following fields must be unset:",
				"-securityContext.windowsOptions",
				"",
				"If the OS field is set to windows, following fields must be unset:",
				"- spec.hostPID",
				"- spec.hostIPC",
				"- spec.hostUsers",
				"- spec.securityContext.appArmorProfile",
				"- spec.securityContext.seLinuxOptions",
				"- spec.securityContext.seccompProfile",
				"- spec.securityContext.fsGroup",
				"- spec.securityContext.fsGroupChangePolicy",
				"- spec.securityContext.sysctls",
				"- spec.shareProcessNamespace",
				"- spec.securityContext.runAsUser",
				"- spec.securityContext.runAsGroup",
				"- spec.securityContext.supplementalGroups",
				"- spec.securityContext.supplementalGroupsPolicy",
				"- spec.containers[*].securityContext.appArmorProfile",
				"- spec.containers[*].securityContext.seLinuxOptions",
				"- spec.containers[*].securityContext.seccompProfile",
				"- spec.containers[*].securityContext.capabilities",
				"- spec.containers[*].securityContext.readOnlyRootFilesystem",
				"- spec.containers[*].securityContext.privileged",
				"- spec.containers[*].securityContext.allowPrivilegeEscalation",
				"- spec.containers[*].securityContext.procMount",
				"- spec.containers[*].securityContext.runAsUser",
				"- spec.containers[*].securityContext.runAsGroup",
			}, true
		case "HostUsers":
			return []string{
				"Use the host's user namespace.",
				"Optional: Default to true.",
				"If set to true or not present, the pod will be run in the host user namespace, useful",
				"for when the pod needs a feature only available to the host user namespace, such as",
				"loading a kernel module with CAP_SYS_MODULE.",
				"When set to false, a new userns is created for the pod. Setting false is useful for",
				"mitigating container breakout vulnerabilities even allowing users to run their",
				"containers as root without actually having root privileges on the host.",
				"This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
			}, true
		case "SchedulingGates":
			return []string{
				"is an opaque list of values that if specified will block scheduling the pod.",
				"If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the",
				"scheduler will not attempt to schedule the pod.",
				"",
				"SchedulingGates can only be set at pod creation time, and be removed only afterwards.",
			}, true
		case "ResourceClaims":
			return []string{
				"defines which ResourceClaims must be allocated",
				"and reserved before the Pod is allowed to start. The resources",
				"will be made available to those containers which consume them",
				"by name.",
				"",
				"This is an alpha field and requires enabling the",
				"DynamicResourceAllocation feature gate.",
				"",
				"This field is immutable.",
			}, true
		case "Resources":
			return []string{
				"is the total amount of CPU and Memory resources required by all",
				"containers in the pod. It supports specifying Requests and Limits for",
				"\"cpu\" and \"memory\" resource names only. ResourceClaims are not supported.",
				"",
				"This field enables fine-grained control over resource allocation for the",
				"entire pod, allowing resource sharing among containers in a pod.",
				"TODO: For beta graduation, expand this comment with a detailed explanation.",
				"",
				"This is an alpha field and requires enabling the PodLevelResources feature",
				"gate.",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *PodPartialTemplateSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Spec":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (*ScopeType) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}

func (v *Service) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Ports":
			return []string{
				"[PortName]servicePort",
			}, true
		case "Paths":
			return []string{
				"[PortName]BashPath",
			}, true
		case "ClusterIP":
			return []string{}, true
		case "Expose":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *ServiceAccount) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Scope":
			return []string{}, true
		case "Rules":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Spec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Version":
			return []string{}, true
		case "Deploy":
			return []string{}, true
		case "Config":
			return []string{}, true
		case "Containers":
			return []string{}, true
		case "Volumes":
			return []string{}, true
		case "Services":
			return []string{}, true
		case "ServiceAccount":
			return []string{}, true
		case "Manifests":
			return []string{}, true
		case "Images":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *StatefulSetSpec) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Replicas":
			return []string{
				"replicas is the desired number of replicas of the given Template.",
				"These are replicas in the sense that they are instantiations of the",
				"same Template, but individual replicas also have a consistent identity.",
				"If unspecified, defaults to 1.",
				"TODO: Consider a rename of this field.",
			}, true
		case "Template":
			return []string{
				"template is the object that describes the pod that will be created if",
				"insufficient replicas are detected. Each pod stamped out by the StatefulSet",
				"will fulfill this Template, but have a unique identity from the rest",
				"of the StatefulSet. Each pod will be named with the format",
				"<statefulsetname>-<podindex>. For example, a pod in a StatefulSet named",
				"\"web\" with index number \"3\" would be named \"web-3\".",
				"The only allowed template.spec.restartPolicy value is \"Always\".",
			}, true
		case "VolumeClaimTemplates":
			return []string{
				"volumeClaimTemplates is a list of claims that pods are allowed to reference.",
				"The StatefulSet controller is responsible for mapping network identities to",
				"claims in a way that maintains the identity of a pod. Every claim in",
				"this list must have at least one matching (by name) volumeMount in one",
				"container in the template. A claim in this list takes precedence over",
				"any volumes in the template, with the same name.",
				"TODO: Define the behavior if a claim already exists with the same name.",
			}, true
		case "ServiceName":
			return []string{
				"serviceName is the name of the service that governs this StatefulSet.",
				"This service must exist before the StatefulSet, and is responsible for",
				"the network identity of the set. Pods get DNS/hostnames that follow the",
				"pattern: pod-specific-string.serviceName.default.svc.cluster.local",
				"where \"pod-specific-string\" is managed by the StatefulSet controller.",
			}, true
		case "PodManagementPolicy":
			return []string{
				"podManagementPolicy controls how pods are created during initial scale up,",
				"when replacing pods on nodes, or when scaling down. The default policy is",
				"`OrderedReady`, where pods are created in increasing order (pod-0, then",
				"pod-1, etc) and the controller will wait until each pod is ready before",
				"continuing. When scaling down, the pods are removed in the opposite order.",
				"The alternative policy is `Parallel` which will create pods in parallel",
				"to match the desired scale without waiting, and on scale down will delete",
				"all pods at once.",
			}, true
		case "UpdateStrategy":
			return []string{
				"updateStrategy indicates the StatefulSetUpdateStrategy that will be",
				"employed to update Pods in the StatefulSet when a revision is made to",
				"Template.",
			}, true
		case "RevisionHistoryLimit":
			return []string{
				"revisionHistoryLimit is the maximum number of revisions that will",
				"be maintained in the StatefulSet's revision history. The revision history",
				"consists of all revisions not represented by a currently applied",
				"StatefulSetSpec version. The default value is 10.",
			}, true
		case "MinReadySeconds":
			return []string{
				"Minimum number of seconds for which a newly created pod should be ready",
				"without any of its container crashing for it to be considered available.",
				"Defaults to 0 (pod will be considered available as soon as it is ready)",
			}, true
		case "PersistentVolumeClaimRetentionPolicy":
			return []string{
				"persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent",
				"volume claims created from volumeClaimTemplates. By default, all persistent",
				"volume claims are created as needed and retained until manually deleted. This",
				"policy allows the lifecycle to be altered, for example by deleting persistent",
				"volume claims when their stateful set is deleted, or when their pod is scaled",
				"down.",
			}, true
		case "Ordinals":
			return []string{
				"ordinals controls the numbering of replica indices in a StatefulSet. The",
				"default ordinals behavior assigns a \"0\" index to the first replica and",
				"increments the index by one for each additional replica requested.",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *Status) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Endpoint":
			return []string{}, true
		case "Resources":
			return []string{}, true
		case "Images":
			return []string{}, true
		case "Digests":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (*Statuses) RuntimeDoc(names ...string) ([]string, bool) {
	return []string{}, true
}

func (v *Volume) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Underlying":
			return []string{}, true
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeConfigMap) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeEmptyDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeHostPath) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeImage) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeMount) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "MountPath":
			return []string{}, true
		case "MountPropagation":
			return []string{}, true
		case "Prefix":
			return []string{
				"mountPath == export, use as envFrom",
			}, true
		case "Optional":
			return []string{}, true
		case "ReadOnly":
			return []string{
				"else volumeMounts",
			}, true
		case "SubPath":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumePersistentVolumeClaim) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v *VolumeSecret) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Type":
			return []string{}, true
		case "Opt":
			return []string{}, true
		case "Spec":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(&v.VolumeMount, "", names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

// nolint:deadcode,unused
func runtimeDoc(v any, prefix string, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		doc, ok := c.RuntimeDoc(names...)
		if ok {
			if prefix != "" && len(doc) > 0 {
				doc[0] = prefix + doc[0]
				return doc, true
			}

			return doc, true
		}
	}
	return nil, false
}
