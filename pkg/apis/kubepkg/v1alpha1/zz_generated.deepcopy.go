/*
Package v1alpha1 GENERATED BY gengo:deepcopy
DON'T EDIT THIS FILE
*/
package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	pkgruntime "k8s.io/apimachinery/pkg/runtime"
)

func (in *ConfigMapSpec) DeepCopy() *ConfigMapSpec {
	if in == nil {
		return nil
	}
	out := new(ConfigMapSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ConfigMapSpec) DeepCopyInto(out *ConfigMapSpec) {
	if in.Data != nil {
		i, o := &in.Data, &out.Data
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
}

func (in *Container) DeepCopy() *Container {
	if in == nil {
		return nil
	}
	out := new(Container)
	in.DeepCopyInto(out)
	return out
}

func (in *Container) DeepCopyInto(out *Container) {
	in.Image.DeepCopyInto(&out.Image)
	out.WorkingDir = in.WorkingDir
	if in.Command != nil {
		i, o := &in.Command, &out.Command
		*o = make([]string, len(*i))
		copy(*o, *i)
	}
	if in.Args != nil {
		i, o := &in.Args, &out.Args
		*o = make([]string, len(*i))
		copy(*o, *i)
	}
	if in.Env != nil {
		i, o := &in.Env, &out.Env
		*o = make(map[string]EnvVarValueOrFrom, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Ports != nil {
		i, o := &in.Ports, &out.Ports
		*o = make(map[string]int32, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	out.Stdin = in.Stdin
	out.StdinOnce = in.StdinOnce
	out.TTY = in.TTY
	out.Resources = in.Resources
	out.LivenessProbe = in.LivenessProbe
	out.ReadinessProbe = in.ReadinessProbe
	out.StartupProbe = in.StartupProbe
	out.Lifecycle = in.Lifecycle
	out.SecurityContext = in.SecurityContext
	out.TerminationMessagePath = in.TerminationMessagePath
	out.TerminationMessagePolicy = in.TerminationMessagePolicy
}

func (in *Image) DeepCopy() *Image {
	if in == nil {
		return nil
	}
	out := new(Image)
	in.DeepCopyInto(out)
	return out
}

func (in *Image) DeepCopyInto(out *Image) {
	out.Name = in.Name
	out.Tag = in.Tag
	out.Digest = in.Digest
	if in.Platforms != nil {
		i, o := &in.Platforms, &out.Platforms
		*o = make([]string, len(*i))
		copy(*o, *i)
	}
	out.PullPolicy = in.PullPolicy
}

func (in *CronJobSpec) DeepCopy() *CronJobSpec {
	if in == nil {
		return nil
	}
	out := new(CronJobSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *CronJobSpec) DeepCopyInto(out *CronJobSpec) {
	out.Schedule = in.Schedule
	out.TimeZone = in.TimeZone
	out.StartingDeadlineSeconds = in.StartingDeadlineSeconds
	out.ConcurrencyPolicy = in.ConcurrencyPolicy
	out.Suspend = in.Suspend
	out.JobTemplate = in.JobTemplate
	out.SuccessfulJobsHistoryLimit = in.SuccessfulJobsHistoryLimit
	out.FailedJobsHistoryLimit = in.FailedJobsHistoryLimit
}

func (in *DaemonSetSpec) DeepCopy() *DaemonSetSpec {
	if in == nil {
		return nil
	}
	out := new(DaemonSetSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *DaemonSetSpec) DeepCopyInto(out *DaemonSetSpec) {
	out.Template = in.Template
	out.UpdateStrategy = *in.UpdateStrategy.DeepCopy()
	out.MinReadySeconds = in.MinReadySeconds
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
}

func (in *DeployConfigMap) DeepCopy() *DeployConfigMap {
	if in == nil {
		return nil
	}
	out := new(DeployConfigMap)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployConfigMap) DeepCopyInto(out *DeployConfigMap) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
}

func (in *DeployInfrastructure) DeepCopy() *DeployInfrastructure {
	if in == nil {
		return nil
	}
	out := new(DeployInfrastructure)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployInfrastructure) DeepCopyInto(out *DeployInfrastructure) {
	if in.Labels != nil {
		i, o := &in.Labels, &out.Labels
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Annotations != nil {
		i, o := &in.Annotations, &out.Annotations
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
}

func (in *DeployCronJob) DeepCopy() *DeployCronJob {
	if in == nil {
		return nil
	}
	out := new(DeployCronJob)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployCronJob) DeepCopyInto(out *DeployCronJob) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *DeployDaemonSet) DeepCopy() *DeployDaemonSet {
	if in == nil {
		return nil
	}
	out := new(DeployDaemonSet)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployDaemonSet) DeepCopyInto(out *DeployDaemonSet) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *DeployDeployment) DeepCopy() *DeployDeployment {
	if in == nil {
		return nil
	}
	out := new(DeployDeployment)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployDeployment) DeepCopyInto(out *DeployDeployment) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *DeploymentSpec) DeepCopy() *DeploymentSpec {
	if in == nil {
		return nil
	}
	out := new(DeploymentSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *DeploymentSpec) DeepCopyInto(out *DeploymentSpec) {
	out.Replicas = in.Replicas
	out.Template = in.Template
	out.Strategy = *in.Strategy.DeepCopy()
	out.MinReadySeconds = in.MinReadySeconds
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
	out.Paused = in.Paused
	out.ProgressDeadlineSeconds = in.ProgressDeadlineSeconds
}

func (in *DeployEndpoints) DeepCopy() *DeployEndpoints {
	if in == nil {
		return nil
	}
	out := new(DeployEndpoints)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployEndpoints) DeepCopyInto(out *DeployEndpoints) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	if in.Ports != nil {
		i, o := &in.Ports, &out.Ports
		*o = make(map[string]int32, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Addresses != nil {
		i, o := &in.Addresses, &out.Addresses
		*o = make([]corev1.EndpointAddress, len(*i))
		copy(*o, *i)
	}
}

func (in *DeployJob) DeepCopy() *DeployJob {
	if in == nil {
		return nil
	}
	out := new(DeployJob)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployJob) DeepCopyInto(out *DeployJob) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *JobSpec) DeepCopy() *JobSpec {
	if in == nil {
		return nil
	}
	out := new(JobSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *JobSpec) DeepCopyInto(out *JobSpec) {
	out.Parallelism = in.Parallelism
	out.Completions = in.Completions
	out.ActiveDeadlineSeconds = in.ActiveDeadlineSeconds
	out.PodFailurePolicy = in.PodFailurePolicy
	out.SuccessPolicy = in.SuccessPolicy
	out.BackoffLimit = in.BackoffLimit
	out.BackoffLimitPerIndex = in.BackoffLimitPerIndex
	out.MaxFailedIndexes = in.MaxFailedIndexes
	out.ManualSelector = in.ManualSelector
	out.Template = in.Template
	out.TTLSecondsAfterFinished = in.TTLSecondsAfterFinished
	out.CompletionMode = in.CompletionMode
	out.Suspend = in.Suspend
	out.PodReplacementPolicy = in.PodReplacementPolicy
	out.ManagedBy = in.ManagedBy
}

func (in *DeploySecret) DeepCopy() *DeploySecret {
	if in == nil {
		return nil
	}
	out := new(DeploySecret)
	in.DeepCopyInto(out)
	return out
}

func (in *DeploySecret) DeepCopyInto(out *DeploySecret) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
}

func (in *DeployStatefulSet) DeepCopy() *DeployStatefulSet {
	if in == nil {
		return nil
	}
	out := new(DeployStatefulSet)
	in.DeepCopyInto(out)
	return out
}

func (in *DeployStatefulSet) DeepCopyInto(out *DeployStatefulSet) {
	out.Kind = in.Kind
	in.DeployInfrastructure.DeepCopyInto(&out.DeployInfrastructure)
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *StatefulSetSpec) DeepCopy() *StatefulSetSpec {
	if in == nil {
		return nil
	}
	out := new(StatefulSetSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *StatefulSetSpec) DeepCopyInto(out *StatefulSetSpec) {
	out.Replicas = in.Replicas
	out.Template = in.Template
	if in.VolumeClaimTemplates != nil {
		i, o := &in.VolumeClaimTemplates, &out.VolumeClaimTemplates
		*o = make([]corev1.PersistentVolumeClaim, len(*i))
		copy(*o, *i)
	}
	out.ServiceName = in.ServiceName
	out.PodManagementPolicy = in.PodManagementPolicy
	out.UpdateStrategy = *in.UpdateStrategy.DeepCopy()
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
	out.MinReadySeconds = in.MinReadySeconds
	out.PersistentVolumeClaimRetentionPolicy = in.PersistentVolumeClaimRetentionPolicy
	out.Ordinals = in.Ordinals
}

func (in *DigestMeta) DeepCopy() *DigestMeta {
	if in == nil {
		return nil
	}
	out := new(DigestMeta)
	in.DeepCopyInto(out)
	return out
}

func (in *DigestMeta) DeepCopyInto(out *DigestMeta) {
	in.Type.DeepCopyInto(&out.Type)
	out.Digest = in.Digest
	out.Name = in.Name
	in.Size.DeepCopyInto(&out.Size)
	out.Tag = in.Tag
	out.Platform = in.Platform
}

func (in *DigestMetaType) DeepCopy() *DigestMetaType {
	if in == nil {
		return nil
	}

	out := new(DigestMetaType)
	in.DeepCopyInto(out)
	return out
}

func (in *DigestMetaType) DeepCopyInto(out *DigestMetaType) {
	*out = *in
}

func (in *FileSize) DeepCopy() *FileSize {
	if in == nil {
		return nil
	}

	out := new(FileSize)
	in.DeepCopyInto(out)
	return out
}

func (in *FileSize) DeepCopyInto(out *FileSize) {
	*out = *in
}

func (in *EnvVarValueOrFrom) DeepCopy() *EnvVarValueOrFrom {
	if in == nil {
		return nil
	}
	out := new(EnvVarValueOrFrom)
	in.DeepCopyInto(out)
	return out
}

func (in *EnvVarValueOrFrom) DeepCopyInto(out *EnvVarValueOrFrom) {
	out.Value = in.Value
	out.ValueFrom = in.ValueFrom
}

func (in *ExposeIngress) DeepCopy() *ExposeIngress {
	if in == nil {
		return nil
	}
	out := new(ExposeIngress)
	in.DeepCopyInto(out)
	return out
}

func (in *ExposeIngress) DeepCopyInto(out *ExposeIngress) {
	out.Type = in.Type
	if in.Gateway != nil {
		i, o := &in.Gateway, &out.Gateway
		*o = make([]string, len(*i))
		copy(*o, *i)
	}
}

func (in *ExposeNodePort) DeepCopy() *ExposeNodePort {
	if in == nil {
		return nil
	}
	out := new(ExposeNodePort)
	in.DeepCopyInto(out)
	return out
}

func (in *ExposeNodePort) DeepCopyInto(out *ExposeNodePort) {
	out.Type = in.Type
}

func (in *JobTemplateSpec) DeepCopy() *JobTemplateSpec {
	if in == nil {
		return nil
	}
	out := new(JobTemplateSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *JobTemplateSpec) DeepCopyInto(out *JobTemplateSpec) {
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *KubePkg) DeepCopyObject() pkgruntime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *KubePkg) DeepCopy() *KubePkg {
	if in == nil {
		return nil
	}
	out := new(KubePkg)
	in.DeepCopyInto(out)
	return out
}

func (in *KubePkg) DeepCopyInto(out *KubePkg) {
	out.TypeMeta = in.TypeMeta
	out.ObjectMeta = *in.ObjectMeta.DeepCopy()
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

func (in *Spec) DeepCopy() *Spec {
	if in == nil {
		return nil
	}
	out := new(Spec)
	in.DeepCopyInto(out)
	return out
}

func (in *Spec) DeepCopyInto(out *Spec) {
	out.Version = in.Version
	in.Deploy.DeepCopyInto(&out.Deploy)
	if in.Config != nil {
		i, o := &in.Config, &out.Config
		*o = make(map[string]EnvVarValueOrFrom, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Containers != nil {
		i, o := &in.Containers, &out.Containers
		*o = make(map[string]Container, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Volumes != nil {
		i, o := &in.Volumes, &out.Volumes
		*o = make(map[string]Volume, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Services != nil {
		i, o := &in.Services, &out.Services
		*o = make(map[string]Service, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	out.ServiceAccount = in.ServiceAccount
	out.Manifests = in.Manifests
	if in.Images != nil {
		i, o := &in.Images, &out.Images
		*o = make(map[string]Image, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
}

func (in *KubePkgList) DeepCopyObject() pkgruntime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *KubePkgList) DeepCopy() *KubePkgList {
	if in == nil {
		return nil
	}
	out := new(KubePkgList)
	in.DeepCopyInto(out)
	return out
}

func (in *KubePkgList) DeepCopyInto(out *KubePkgList) {
	out.TypeMeta = in.TypeMeta
	out.ListMeta = *in.ListMeta.DeepCopy()
	if in.Items != nil {
		i, o := &in.Items, &out.Items
		*o = make([]KubePkg, len(*i))
		copy(*o, *i)
	}
}

func (in *PodPartialSpec) DeepCopy() *PodPartialSpec {
	if in == nil {
		return nil
	}
	out := new(PodPartialSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *PodPartialSpec) DeepCopyInto(out *PodPartialSpec) {
	out.RestartPolicy = in.RestartPolicy
	out.TerminationGracePeriodSeconds = in.TerminationGracePeriodSeconds
	out.ActiveDeadlineSeconds = in.ActiveDeadlineSeconds
	out.DNSPolicy = in.DNSPolicy
	if in.NodeSelector != nil {
		i, o := &in.NodeSelector, &out.NodeSelector
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	out.AutomountServiceAccountToken = in.AutomountServiceAccountToken
	out.NodeName = in.NodeName
	out.HostNetwork = in.HostNetwork
	out.HostPID = in.HostPID
	out.HostIPC = in.HostIPC
	out.ShareProcessNamespace = in.ShareProcessNamespace
	out.SecurityContext = in.SecurityContext
	if in.ImagePullSecrets != nil {
		i, o := &in.ImagePullSecrets, &out.ImagePullSecrets
		*o = make([]corev1.LocalObjectReference, len(*i))
		copy(*o, *i)
	}
	out.Hostname = in.Hostname
	out.Subdomain = in.Subdomain
	out.Affinity = in.Affinity
	out.SchedulerName = in.SchedulerName
	if in.Tolerations != nil {
		i, o := &in.Tolerations, &out.Tolerations
		*o = make([]corev1.Toleration, len(*i))
		copy(*o, *i)
	}
	if in.HostAliases != nil {
		i, o := &in.HostAliases, &out.HostAliases
		*o = make([]corev1.HostAlias, len(*i))
		copy(*o, *i)
	}
	out.PriorityClassName = in.PriorityClassName
	out.Priority = in.Priority
	out.DNSConfig = in.DNSConfig
	if in.ReadinessGates != nil {
		i, o := &in.ReadinessGates, &out.ReadinessGates
		*o = make([]corev1.PodReadinessGate, len(*i))
		copy(*o, *i)
	}
	out.RuntimeClassName = in.RuntimeClassName
	out.EnableServiceLinks = in.EnableServiceLinks
	out.PreemptionPolicy = in.PreemptionPolicy
	out.Overhead = in.Overhead.DeepCopy()
	if in.TopologySpreadConstraints != nil {
		i, o := &in.TopologySpreadConstraints, &out.TopologySpreadConstraints
		*o = make([]corev1.TopologySpreadConstraint, len(*i))
		copy(*o, *i)
	}
	out.SetHostnameAsFQDN = in.SetHostnameAsFQDN
	out.OS = in.OS
	out.HostUsers = in.HostUsers
	if in.SchedulingGates != nil {
		i, o := &in.SchedulingGates, &out.SchedulingGates
		*o = make([]corev1.PodSchedulingGate, len(*i))
		copy(*o, *i)
	}
	if in.ResourceClaims != nil {
		i, o := &in.ResourceClaims, &out.ResourceClaims
		*o = make([]corev1.PodResourceClaim, len(*i))
		copy(*o, *i)
	}
	out.Resources = in.Resources
}

func (in *PodPartialTemplateSpec) DeepCopy() *PodPartialTemplateSpec {
	if in == nil {
		return nil
	}
	out := new(PodPartialTemplateSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *PodPartialTemplateSpec) DeepCopyInto(out *PodPartialTemplateSpec) {
	in.Spec.DeepCopyInto(&out.Spec)
}

func (in *ScopeType) DeepCopy() *ScopeType {
	if in == nil {
		return nil
	}

	out := new(ScopeType)
	in.DeepCopyInto(out)
	return out
}

func (in *ScopeType) DeepCopyInto(out *ScopeType) {
	*out = *in
}

func (in *Service) DeepCopy() *Service {
	if in == nil {
		return nil
	}
	out := new(Service)
	in.DeepCopyInto(out)
	return out
}

func (in *Service) DeepCopyInto(out *Service) {
	if in.Ports != nil {
		i, o := &in.Ports, &out.Ports
		*o = make(map[string]int32, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Paths != nil {
		i, o := &in.Paths, &out.Paths
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	out.ClusterIP = in.ClusterIP
	out.Expose = in.Expose
}

func (in *ServiceAccount) DeepCopy() *ServiceAccount {
	if in == nil {
		return nil
	}
	out := new(ServiceAccount)
	in.DeepCopyInto(out)
	return out
}

func (in *ServiceAccount) DeepCopyInto(out *ServiceAccount) {
	in.Scope.DeepCopyInto(&out.Scope)
	if in.Rules != nil {
		i, o := &in.Rules, &out.Rules
		*o = make([]rbacv1.PolicyRule, len(*i))
		copy(*o, *i)
	}
}

func (in *Status) DeepCopy() *Status {
	if in == nil {
		return nil
	}
	out := new(Status)
	in.DeepCopyInto(out)
	return out
}

func (in *Status) DeepCopyInto(out *Status) {
	if in.Endpoint != nil {
		i, o := &in.Endpoint, &out.Endpoint
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Resources != nil {
		i, o := &in.Resources, &out.Resources
		*o = make([]map[string]any, len(*i))
		copy(*o, *i)
	}
	if in.Images != nil {
		i, o := &in.Images, &out.Images
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	if in.Digests != nil {
		i, o := &in.Digests, &out.Digests
		*o = make([]DigestMeta, len(*i))
		copy(*o, *i)
	}
}

func (in Statuses) DeepCopy() Statuses {
	if in == nil {
		return nil
	}
	out := make(Statuses)
	in.DeepCopyInto(out)
	return out
}

func (in Statuses) DeepCopyInto(out Statuses) {
	for k := range in {
		out[k] = in[k]
	}
}

func (in *VolumeConfigMap) DeepCopy() *VolumeConfigMap {
	if in == nil {
		return nil
	}
	out := new(VolumeConfigMap)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeConfigMap) DeepCopyInto(out *VolumeConfigMap) {
	out.Type = in.Type
	out.Opt = in.Opt
	out.Spec = in.Spec
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *VolumeMount) DeepCopy() *VolumeMount {
	if in == nil {
		return nil
	}
	out := new(VolumeMount)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeMount) DeepCopyInto(out *VolumeMount) {
	out.MountPath = in.MountPath
	out.MountPropagation = in.MountPropagation
	out.Prefix = in.Prefix
	out.Optional = in.Optional
	out.ReadOnly = in.ReadOnly
	out.SubPath = in.SubPath
}

func (in *VolumeEmptyDir) DeepCopy() *VolumeEmptyDir {
	if in == nil {
		return nil
	}
	out := new(VolumeEmptyDir)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeEmptyDir) DeepCopyInto(out *VolumeEmptyDir) {
	out.Type = in.Type
	out.Opt = in.Opt
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *VolumeHostPath) DeepCopy() *VolumeHostPath {
	if in == nil {
		return nil
	}
	out := new(VolumeHostPath)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeHostPath) DeepCopyInto(out *VolumeHostPath) {
	out.Type = in.Type
	out.Opt = in.Opt
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *VolumeImage) DeepCopy() *VolumeImage {
	if in == nil {
		return nil
	}
	out := new(VolumeImage)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeImage) DeepCopyInto(out *VolumeImage) {
	out.Type = in.Type
	out.Opt = in.Opt
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *VolumePersistentVolumeClaim) DeepCopy() *VolumePersistentVolumeClaim {
	if in == nil {
		return nil
	}
	out := new(VolumePersistentVolumeClaim)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumePersistentVolumeClaim) DeepCopyInto(out *VolumePersistentVolumeClaim) {
	out.Type = in.Type
	out.Opt = in.Opt
	out.Spec = *in.Spec.DeepCopy()
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *VolumeSecret) DeepCopy() *VolumeSecret {
	if in == nil {
		return nil
	}
	out := new(VolumeSecret)
	in.DeepCopyInto(out)
	return out
}

func (in *VolumeSecret) DeepCopyInto(out *VolumeSecret) {
	out.Type = in.Type
	out.Opt = in.Opt
	out.Spec = in.Spec
	in.VolumeMount.DeepCopyInto(&out.VolumeMount)
}

func (in *cronJobSpec) DeepCopy() *cronJobSpec {
	if in == nil {
		return nil
	}
	out := new(cronJobSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *cronJobSpec) DeepCopyInto(out *cronJobSpec) {
	out.Schedule = in.Schedule
	out.TimeZone = in.TimeZone
	out.StartingDeadlineSeconds = in.StartingDeadlineSeconds
	out.ConcurrencyPolicy = in.ConcurrencyPolicy
	out.Suspend = in.Suspend
	out.JobTemplate = *in.JobTemplate.DeepCopy()
	out.SuccessfulJobsHistoryLimit = in.SuccessfulJobsHistoryLimit
	out.FailedJobsHistoryLimit = in.FailedJobsHistoryLimit
}

func (in *daemonSetSpec) DeepCopy() *daemonSetSpec {
	if in == nil {
		return nil
	}
	out := new(daemonSetSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *daemonSetSpec) DeepCopyInto(out *daemonSetSpec) {
	out.Selector = in.Selector
	out.Template = *in.Template.DeepCopy()
	out.UpdateStrategy = *in.UpdateStrategy.DeepCopy()
	out.MinReadySeconds = in.MinReadySeconds
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
}

func (in *deploymentSpec) DeepCopy() *deploymentSpec {
	if in == nil {
		return nil
	}
	out := new(deploymentSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *deploymentSpec) DeepCopyInto(out *deploymentSpec) {
	out.Replicas = in.Replicas
	out.Selector = in.Selector
	out.Template = *in.Template.DeepCopy()
	out.Strategy = *in.Strategy.DeepCopy()
	out.MinReadySeconds = in.MinReadySeconds
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
	out.Paused = in.Paused
	out.ProgressDeadlineSeconds = in.ProgressDeadlineSeconds
}

func (in *jobSpec) DeepCopy() *jobSpec {
	if in == nil {
		return nil
	}
	out := new(jobSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *jobSpec) DeepCopyInto(out *jobSpec) {
	out.Parallelism = in.Parallelism
	out.Completions = in.Completions
	out.ActiveDeadlineSeconds = in.ActiveDeadlineSeconds
	out.PodFailurePolicy = in.PodFailurePolicy
	out.SuccessPolicy = in.SuccessPolicy
	out.BackoffLimit = in.BackoffLimit
	out.BackoffLimitPerIndex = in.BackoffLimitPerIndex
	out.MaxFailedIndexes = in.MaxFailedIndexes
	out.Selector = in.Selector
	out.ManualSelector = in.ManualSelector
	out.Template = *in.Template.DeepCopy()
	out.TTLSecondsAfterFinished = in.TTLSecondsAfterFinished
	out.CompletionMode = in.CompletionMode
	out.Suspend = in.Suspend
	out.PodReplacementPolicy = in.PodReplacementPolicy
	out.ManagedBy = in.ManagedBy
}

func (in *podPartialSpec) DeepCopy() *podPartialSpec {
	if in == nil {
		return nil
	}
	out := new(podPartialSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *podPartialSpec) DeepCopyInto(out *podPartialSpec) {
	if in.Volumes != nil {
		i, o := &in.Volumes, &out.Volumes
		*o = make([]corev1.Volume, len(*i))
		copy(*o, *i)
	}
	if in.InitContainers != nil {
		i, o := &in.InitContainers, &out.InitContainers
		*o = make([]corev1.Container, len(*i))
		copy(*o, *i)
	}
	if in.Containers != nil {
		i, o := &in.Containers, &out.Containers
		*o = make([]corev1.Container, len(*i))
		copy(*o, *i)
	}
	if in.EphemeralContainers != nil {
		i, o := &in.EphemeralContainers, &out.EphemeralContainers
		*o = make([]corev1.EphemeralContainer, len(*i))
		copy(*o, *i)
	}
	out.RestartPolicy = in.RestartPolicy
	out.TerminationGracePeriodSeconds = in.TerminationGracePeriodSeconds
	out.ActiveDeadlineSeconds = in.ActiveDeadlineSeconds
	out.DNSPolicy = in.DNSPolicy
	if in.NodeSelector != nil {
		i, o := &in.NodeSelector, &out.NodeSelector
		*o = make(map[string]string, len(*i))
		for key, val := range *i {
			(*o)[key] = val
		}
	}
	out.ServiceAccountName = in.ServiceAccountName
	out.DeprecatedServiceAccount = in.DeprecatedServiceAccount
	out.AutomountServiceAccountToken = in.AutomountServiceAccountToken
	out.NodeName = in.NodeName
	out.HostNetwork = in.HostNetwork
	out.HostPID = in.HostPID
	out.HostIPC = in.HostIPC
	out.ShareProcessNamespace = in.ShareProcessNamespace
	out.SecurityContext = in.SecurityContext
	if in.ImagePullSecrets != nil {
		i, o := &in.ImagePullSecrets, &out.ImagePullSecrets
		*o = make([]corev1.LocalObjectReference, len(*i))
		copy(*o, *i)
	}
	out.Hostname = in.Hostname
	out.Subdomain = in.Subdomain
	out.Affinity = in.Affinity
	out.SchedulerName = in.SchedulerName
	if in.Tolerations != nil {
		i, o := &in.Tolerations, &out.Tolerations
		*o = make([]corev1.Toleration, len(*i))
		copy(*o, *i)
	}
	if in.HostAliases != nil {
		i, o := &in.HostAliases, &out.HostAliases
		*o = make([]corev1.HostAlias, len(*i))
		copy(*o, *i)
	}
	out.PriorityClassName = in.PriorityClassName
	out.Priority = in.Priority
	out.DNSConfig = in.DNSConfig
	if in.ReadinessGates != nil {
		i, o := &in.ReadinessGates, &out.ReadinessGates
		*o = make([]corev1.PodReadinessGate, len(*i))
		copy(*o, *i)
	}
	out.RuntimeClassName = in.RuntimeClassName
	out.EnableServiceLinks = in.EnableServiceLinks
	out.PreemptionPolicy = in.PreemptionPolicy
	out.Overhead = in.Overhead.DeepCopy()
	if in.TopologySpreadConstraints != nil {
		i, o := &in.TopologySpreadConstraints, &out.TopologySpreadConstraints
		*o = make([]corev1.TopologySpreadConstraint, len(*i))
		copy(*o, *i)
	}
	out.SetHostnameAsFQDN = in.SetHostnameAsFQDN
	out.OS = in.OS
	out.HostUsers = in.HostUsers
	if in.SchedulingGates != nil {
		i, o := &in.SchedulingGates, &out.SchedulingGates
		*o = make([]corev1.PodSchedulingGate, len(*i))
		copy(*o, *i)
	}
	if in.ResourceClaims != nil {
		i, o := &in.ResourceClaims, &out.ResourceClaims
		*o = make([]corev1.PodResourceClaim, len(*i))
		copy(*o, *i)
	}
	out.Resources = in.Resources
}

func (in *statefulSetSpec) DeepCopy() *statefulSetSpec {
	if in == nil {
		return nil
	}
	out := new(statefulSetSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *statefulSetSpec) DeepCopyInto(out *statefulSetSpec) {
	out.Replicas = in.Replicas
	out.Selector = in.Selector
	out.Template = *in.Template.DeepCopy()
	if in.VolumeClaimTemplates != nil {
		i, o := &in.VolumeClaimTemplates, &out.VolumeClaimTemplates
		*o = make([]corev1.PersistentVolumeClaim, len(*i))
		copy(*o, *i)
	}
	out.ServiceName = in.ServiceName
	out.PodManagementPolicy = in.PodManagementPolicy
	out.UpdateStrategy = *in.UpdateStrategy.DeepCopy()
	out.RevisionHistoryLimit = in.RevisionHistoryLimit
	out.MinReadySeconds = in.MinReadySeconds
	out.PersistentVolumeClaimRetentionPolicy = in.PersistentVolumeClaimRetentionPolicy
	out.Ordinals = in.Ordinals
}
